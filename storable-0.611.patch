diff -ur --new-file Storable-0.6.11/Storable.pm S/Storable.pm
--- Storable-0.6.11/Storable.pm	Sun Apr  2 23:48:13 2000
+++ S/Storable.pm	Sun Jun 11 20:28:14 2000
@@ -61,7 +61,7 @@
 use Carp;
 use vars qw($forgive_me $VERSION);
 
-$VERSION = '0.611';
+$VERSION = '0.6111';
 *AUTOLOAD = \&AutoLoader::AUTOLOAD;		# Grrr...
 
 bootstrap Storable;
diff -ur --new-file Storable-0.6.11/Storable.xs S/Storable.xs
--- Storable-0.6.11/Storable.xs	Sun Apr  2 23:48:13 2000
+++ S/Storable.xs	Sun Jun 11 20:27:36 2000
@@ -106,6 +106,16 @@
 #define ASSERT(x,y)
 #endif
 
+/* quick but very ugly (relatively slows as well)
+ * fix to enable overloading.
+ */
+#define FIX_OVERLOAD(rv)				\
+        if (SvOBJECT (SvRV (rv)))			\
+          {						\
+            HV *stash = (HV *) SvSTASH (SvRV (rv));	\
+            if (stash && Gv_AMG (stash))		\
+              SvAMAGIC_on((rv));			\
+          }
 /*
  * Type markers.
  */
@@ -1295,10 +1305,11 @@
 	char buf[256];	/* Enough room for 256 hexa digits */
 	unsigned char c;
 
-	TRACEME(("magic_write on fd=%d", fileno(f)));
-
 	if (f)
+          {
+        	TRACEME(("magic_write on fd=%d", fileno(f)));
 		WRITE(magicstr, strlen(magicstr));	/* Don't write final \0 */
+          }
 
 	/*
 	 * Starting with 0.6, the "use_network_order" byte flag is also used to
@@ -1547,6 +1558,8 @@
 	SvRV(rv) = sv;				/* $rv = \$sv */
 	SvROK_on(rv);
 
+        FIX_OVERLOAD (rv);
+
 	TRACEME(("ok (retrieve_ref at 0x%lx)", (unsigned long) rv));
 
 	return rv;
@@ -2580,7 +2593,10 @@
 			return sv;
 	}
 
-	return newRV_noinc(sv);
+        sv = newRV_noinc (sv);
+        FIX_OVERLOAD (sv);
+
+	return sv;
 }
 
 /*
diff -ur --new-file Storable-0.6.11/t/ovrld.t S/t/ovrld.t
--- Storable-0.6.11/t/ovrld.t	Thu Jan  1 01:00:00 1970
+++ S/t/ovrld.t	Sun Jun 11 20:26:02 2000
@@ -0,0 +1,25 @@
+#!./perl
+
+use Storable qw(freeze thaw);
+
+print "1..4\n";
+
+package OVERLOADED;
+
+use overload
+   '""' => sub { $_[0][0] };
+
+package main;
+
+$a = bless [77], OVERLOADED;
+
+$b = thaw freeze $a;
+$c = thaw freeze \$a;
+$d = thaw freeze [$a, $a];
+
+print "$b"  eq "77" ? "" : "not ", "ok 1\n";
+print "$$c" eq "77" ? "" : "not ", "ok 2\n";
+print "$d->[0]" eq "77" ? "" : "not ", "ok 3\n";
+$d->[0][0]++;
+print "$d->[1]" eq "78" ? "" : "not ", "ok 4\n";
+
