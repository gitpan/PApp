<papp name="papp">

<xperl><![CDATA[

=head1 NAME

macro/editform - macros used for creating sql editing forms

=head1 SYNOPSIS

 <import src="macro/editform"/>

=head1 DESCRIPTION

*sigh* :(

=cut

sub ef_edit*() {
   $S{ef_edit};
}

my $EF_KEY = "ef000000";
my $ef_args;

sub ef_nextid($) {
   my $field = shift;
   my $key = $EF_KEY++;
   $ef_args->{$key}{field} = $field;
   $key;
}

]]></xperl>

<macro name="ef_parse*"><phtml><![CDATA[
<:
   my $ef = delete $A{ef_args};
   return unless $ef;
   local *FILE;
   my %multi;

   if (reload_p) {
      echo __"[not updating anything due to page reload]", "<br>";
   } else {
      my %set;
      parse_multipart_form {
         my ($fh, $name, $ct, $cd) = @_;
         my $data;
         my $field = $ef->{$name};

         if (defined $field->{field}) {
            $fh->read($data, 1024*128);
            $data =~ s/\r\n$//;
            if (exists $field->{multi}) {
               push @{$field->{multi}}, $data;
            } else {
               ${$field->{field}} = $data;
            }
         } elsif (my $path = $field->{path}) {
            my $prev;
            echo "<tt>";
            echo "file upload to '$path'<br>";
            if (open FILE, ">", "$path~") {
               my $size = 0;
               while ($fh->read($data, 16*1024) > 0) {
                  $size += length $data;
                  print FILE $prev, substr($data, 0, length($data) - 2);
                  $prev = substr $data, -2;
               }
               if ($prev ne "\015\012") {
                  echo "=&gt;&nbsp;WARNING: no trailing CRLF found<br>";
                  print FILE $prev;
               } else {
                  $size -= 2;
               }
               close FILE;
               if ($size > 0) {
                  echo "=&gt;&nbsp;read $size bytes<br>";
                  rename "$path~", $path;
                  echo "=&gt;&nbsp;renaming to final destination ($!)<br>";
               } else {
                  unlink "$path~";
                  echo "=&gt;&nbsp;empty file upload ignored<br>";
               }
            } else {
               echo "=&gt;&nbsp;$path~: $!<br>";
            }
            echo "</tt>";
         } else {
            # submit et. al.
         }
         return 1;
      };

      for my $field (values %$ef) {
         ${$field->{field}} = $field->{multi}    if exists $field->{multi};
         ${$field->{field}} = $field->{constant} if exists $field->{constant};
      }
   }
   return 1;
:>
]]></phtml></macro>

<macro name="ef_may_edit*"><phtml><![CDATA[
#if $S{ef_edit}
   <?slink __"[Leave Edit Mode]", ef_edit => undef:><p>
#else
   <?slink __"[Enter Edit Mode]", ef_edit => 1:><p>
#endif
]]></phtml></macro>

<macro name="ef_submit*(;$)" args="$text"><phtml><![CDATA[
   <?submit "submit_editform", $text || __"Save Changes":>
]]></phtml></macro>

<macro name="ef_reset*"><phtml><![CDATA[
   <?submit "reset", __"Restore Values":>
]]></phtml></macro>

<macro name="ef_begin*"><phtml><![CDATA[
   <:ef_parse:>
   <?
      multipart_form;
   :>
]]></phtml></macro>

<macro name="ef_end*"><phtml><![CDATA[<:
   echo endform -ef_args => $ef_args;
   undef $ef_args;
:>]]></phtml></macro>

<macro name="ef_string*" args="$field $len"><phtml><![CDATA[
   <?textfield ef_nextid($field), value => $$field, size => $len||20:>
]]></phtml></macro>

<macro name="ef_text*" args="$field $w $h"><phtml><![CDATA[
   <:$h ||= int (length ($content) / ($w-5.0001)) + 30:>
   <?textarea ef_nextid($field), cols => $w, rows => $h, wrap => undef?><?escape_html $$field:></textarea>
]]></phtml></macro>

<![CDATA[
=item ef_optionbox $ref, values...

Creates an optionbox for the given values. If $$ref evaluates to an
array-ref a multiple-select optionbox is created, otherwise a simple
single-select box is used. C<values>... can be as many C<value =>
description< pairs as you like.

=cut
]]>

<macro name="ef_optionbox*" args="$field @values"><phtml><![CDATA[
<:
   my $values = ref $values[0] eq "ARRAY" ? $values[0] : \@values;

   my %content;
   my $content = $$field;

   my $id = ef_nextid $field;

   if (ref $content) {
      @content{@$content} = ();
      echo "<select name=$id multiple>";
      $ef_args->{$id}{multi} = [];
   } else {
      $content{$content} = ();
      echo "<select name=$id>";
   }

   for (my $i = 0; $i < $#$values; $i += 2) {
      echo "<option";
      echo " selected" if exists $content{$$values[$i]};
      echo " value=".escape_attr($$values[$i]).">".escape_html($$values[$i+1])."</option>";
   }
   echo "</select>";
:>
]]></phtml></macro>

<macro name="ef_relation*" args="$field $relation @values"><phtml><![CDATA[
<:
   my ($sel, @arg) = @$relation;
   my $st = sql_exec \my($id,$val), "select $sel order by 2";
   push @values, $id => $val while $st->fetch;
   ef_optionbox $field, \@values;
:>
]]></phtml></macro>

<macro name="ef_set*" args="$field $relation"><phtml><![CDATA[
<:
   my ($table, $fild) = @$relation;
   my $st = sql_exec "show columns from $table like ?", $fild;
   my $type = $st->fetchrow_arrayref->[1];
   $type =~ s/^set\('(.*)'\)$/$1/ or die "ef_set: field '$fild' is not of set type\n";

   ef_optionbox $field, map {$_, $_} split /','/, $type;

   #ef_optionbox [split /,/, $$field], $field, [ map {$_, $_} split /','/, $type ];
:>
]]></phtml></macro>

<macro name="ef_file*" args="$path"><phtml><![CDATA[
<:
   my $id = ef_nextid(undef);
   $ef_args->{$id}{path} = $path;
   echo filefield $id;
:>
]]></phtml></macro>

<macro name="ef_constant*" args="$field $value"><phtml><![CDATA[
<:
   my $id = ef_nextid($field);
   $ef_args->{$id}{constant} = $value;
?>
]]></phtml></macro>

<perl><![CDATA[
=head1 SEE ALSO

L<PApp>

=head1 AUTHOR

 Marc Lehmann <pcg@goof.com>
 http://www.goof.com/pcg/marc/

=cut
]]></perl>

</papp>

