<package name="ssl">
<domain name="papp" lang="en">

<perl><![CDATA[
=head1 NAME

macro/ssl - mod_ssl-helpers for PApp

=head1 SYNOPSIS

	<import src="macro/ssl"/>

=head1 DESCRIPTION

Helper functions for apache/mod_ssl.
Some functions support three-state pages, the PApp application
should be mounted on three different virtual hosts in Apache.
The three states some functions assume are:

   http://host:80/foobar      - plain http without any encryption (url_prefix_nossl)
   https://host:443/foobar    - anonymous https (no client cert required) (url_prefix_ssl)
   https://host:444/foobar    - require full client authentification (url_prefix_sslauth)

Port 444 is nonstandard, so you can override these in your mountconfig.
It's a good idea to override all three values, because the fallback
uses $request->hostname, which may give unexpected results.
If you only define url_prefix_ssl (say to "https://secure.w3.org"),
the following can happen if the plain request goes to http://seppl.org:

normal sections     http://seppl.org
<:ssl_needed:>      https://secure.w3.org
<:ssl_user_needed:> https://secure.w3.org:444

if you switch directly from normal to auth:

normal sections     http://seppl.org
<:ssl_user_needed:> https://seppl.org:444 

So PLEASE override all three settings (url_prefix_nossl, url_prefix_ssl
and url_prefix_sslauth) to get a consistent behavior...

If you want to kick out nonstandard port 444 you need a IP-virtual
Host configuration because the https protocol does not support
the Host request-header. You should also use different server-keys for
ssl and sslauth or you may get warnings in client browser about
mismatch of real-hostname and the hostname in the server certificate.

url_prefix_nossl   => http://seppl.org
url_prefix_ssl	   => https://seppl.org     (cert for "seppl.org")
url_prefix_sslauth => https://auth.seppl.org (cert for "auth.seppl.org")

for example, use:
SSLCertificateFile /share/www/conf/ssl.crt/server.crt.seppl.org
SSLCertificateKeyFile /share/www/conf/ssl.key/server.key.seppl.org

in the seppl.org https-section and the following for auth.seppl.org

SSLCertificateFile /share/www/conf/ssl.crt/server.crt.auth.seppl.org
SSLCertificateKeyFile /share/www/conf/ssl.key/server.auth.key.seppl.org

So the easier setup is to use 444 because you need only one server
certificate and you don't need to deal with url_prefix.

This is a convention used by this package, not standard mod_ssl setup.

It is always possible to detect the current SSL state like this:

   #if ssl_p
   <?"under SSL":>
   # if ssl_user
   <?" with user auth: " . ssl_user:>
   # else
   <?" without user auth":>
   # endif
   #else
   <?"no SSL":>
   #endif

The defined states are only needed to switch to a higher auth-level by
redirection.

To enforce SSL you can use:

<:ssl_needed:>

and if you require strict client authentification you can use:

<:ssl_user_needed:>

=head1 Apache Sample Configuration

Use the following directives for SSL (strong 128bit encryption)
on Port 443 (standard SSL without user auth).

    SSLVerifyDepth 1
    SSLCACertificateFile conf/ssl.crt/ca.crt
    SSLEngine on
    SSLCipherSuite HIGH:MEDIUM
    SSLCertificateFile /usr/www/conf/ssl.crt/server.crt
    SSLCertificateKeyFile /usr/www/conf/ssl.key/server.key
    SSLCARevocationPath /usr/www/conf/ssl.crl
    SSLOptions +StdEnvVars
    <Perl>
      search_path PApp "/usr/www/lib/papp";
      search_path PApp "/usr/www/lib/papp/macro";
      mount_appset PApp default;
    </Perl>

Use the exact same configuration on port 444 and in addition -
enable user authentification by adding:

    SSLVerifyClient require
    
=head1 FUNCTIONS

=over 4

=item ssl_p

Returns true if the current request is a https request.

=item ssl_user

Returns the user name of the client certificate or C<undef>
if there is no SSL-session at all or if the SSL-session is
anonymous (without a client certificate)

=item ssl_needed

Redirects the current request to a secure non-user authentificated
SSL connection if insecure http protocol is used.

=item ssl_user_needed

Like C<ssl_needed> but requires user authentification.

=item no_ssl

Redirects the current request to http if https is used.
This can be used to drop SSL security.
   
=back

=cut

]]></perl>

<import pm="PApp::User"/>

<macro name="_sslrealautologin($)"><perl><![CDATA[
# we don't check if the Cert is valid and
# not expired, Apache does this; place revokes there :)
   user_login $_[0];
]]></perl></macro>

<macro name="_sslautologin()"><perl><![CDATA[
 $su = $ENV{SSL_CLIENT_S_DN_CN};
 $tmp = sql_fetch $PApp::Config::DBH,
       "select id from ssluser where cert = ?", $su;
 return _sslrealautologin $tmp if $tmp;
 # ok new SSL user.
 # special case: Same cookie for two Certificates
 # if two certs are installed for a single user...
 user_login 0;
 sql_exec $PApp::Config::DBH, 
 	"insert into ssluser values (?,?)",
        $userid, $su;
 # set the user-name (simple version)
 $username = $su;
 $username =~ s/[ \t]/_/g;
 # Avoid overwriting existing users.
 while(! update_username $username)  {
 	$username = choose_username $username;
 }
 update_password undef; # no "normal" password login allowed, SSL only.
 update_comment "SSL Cert Account $ENV{SSL_CLIENT_S_DN}";
 _sslrealautologin $userid;
]]></perl></macro>

<perl><![CDATA[
sub _url_prefix_nossl_host() {
   return "http://" . $request->hostname unless $papp->{url_prefix_nossl};
   $papp->{url_prefix_nossl};
}
sub _url_prefix_ssl_host() {
   return "https://" . $request->hostname . ":443" unless $papp->{url_prefix_ssl};
   $papp->{url_prefix_ssl};
}
sub _url_prefix_sslauth_host() {
   return "https://" . $request->hostname . ":444" unless $papp->{url_prefix_sslauth};
   $papp->{url_prefix_sslauth};
}
]]></perl>

<macro name="ssl_p*()"><perl><![CDATA[
   defined $ENV{SSL_PROTOCOL};
]]></perl></macro>

<macro name="ssl_user*()"><perl><![CDATA[
   return () unless $ENV{SSL_CLIENT_VERIFY} eq 'SUCCESS';
   _sslautologin unless authen_p;
   $ENV{SSL_CLIENT_S_DN_CN};
]]></perl></macro>

<macro name="ssl_needed*()"><perl><![CDATA[
   return if defined $ENV{SSL_PROTOCOL};
   redirect _url_prefix_ssl_host . surl map { -$_, $A{$_} } keys %A;
]]></perl></macro>

<macro name="ssl_user_needed*()"><perl><![CDATA[
   if ($ENV{SSL_CLIENT_VERIFY} eq 'SUCCESS') {
   	_sslautologin unless authen_p;
   	return;
   }
   redirect _url_prefix_sslauth_host . surl map { -$_, $A{$_} } keys %A;
]]></perl></macro>

<macro name="no_ssl*()"><perl><![CDATA[
   return unless defined $ENV{SSL_PROTOCOL};
   redirect _url_prefix_nossl . surl map { -$_, $A{$_} } keys %A;
]]></perl></macro>

<macro name="SSLClientEmail*()"><perl><![CDATA[
 $ENV{SSL_CLIENT_S_DN_Email}
]]></perl></macro>

<macro name="SSLClientCountry*()"><perl><![CDATA[
 $ENV{SSL_CLIENT_S_DN_C}
]]></perl></macro>

<macro name="SSLClientState*()"><perl><![CDATA[
 $ENV{SSL_CLIENT_S_DN_ST}
]]></perl></macro>

<macro name="SSLClientLocation*()"><perl><![CDATA[
 $ENV{SSL_CLIENT_S_DN_L}
]]></perl></macro>

<macro name="SSLClientOrganization*()"><perl><![CDATA[
 $ENV{SSL_CLIENT_S_DN_O}
]]></perl></macro>

<macro name="SSLClientOrganizationalUnit*()"><perl><![CDATA[
 $ENV{SSL_CLIENT_S_DN_OU}
]]></perl></macro>

<macro name="SSLClientName*()"><perl><![CDATA[
 $ENV{SSL_CLIENT_S_DN_CN}
]]></perl></macro>


<perl><![CDATA[

=head1 SEE ALSO

L<PApp>

=head1 AUTHOR

This module was kindly contributed by
Stefan Traby <stefan@hello-penguin.com>.

=cut

]]></perl>

</domain>
</package>

